import jsPDF from 'jspdf';
import 'jspdf-autotable';
import { format } from 'date-fns';

// Types of data we'll need for the PDF
interface MilestoneData {
  date: Date;
  description: string;
}

interface ChildData {
  id: string;
  name: string; 
  dateOfBirth?: string;
  age?: string;
  milestones?: MilestoneData[];
  measurements?: {
    date: Date;
    weight?: number;
    height?: number;
    headCircumference?: number;
  }[];
  appointments?: {
    date: Date;
    type: string;
    notes?: string;
  }[];
  photos?: {
    url: string;
    caption?: string;
    date: Date;
  }[];
}

interface PDFOptions {
  includeMilestones: boolean;
  includeGrowth: boolean;
  includePhotos: boolean;
  includeAppointments: boolean;
  title?: string;
  startDate?: Date;
  endDate?: Date;
  recipientEmail?: string;
}

/**
 * Generate a PDF report of a child's development over a period of time
 * 
 * @param childData Data for the child
 * @param options Options for what to include in the PDF
 * @returns PDF document as Blob
 */
export const generateChildPDF = async (childData: ChildData, options: PDFOptions): Promise<Blob> => {
  // Create a new PDF document
  const doc = new jsPDF();
  
  // Default title with date range if not provided
  const title = options.title || `${childData.name}'s Development Report`;
  
  // Format date range for the subtitle
  const startDate = options.startDate ? format(options.startDate, 'MMM d, yyyy') : 'Birth';
  const endDate = options.endDate ? format(options.endDate, 'MMM d, yyyy') : format(new Date(), 'MMM d, yyyy');
  const dateRange = `${startDate} to ${endDate}`;
  
  // Add title and header
  doc.setFontSize(24);
  doc.setTextColor(64, 122, 214); // Primary color
  doc.text(title, 105, 20, { align: 'center' });
  
  doc.setFontSize(14);
  doc.setTextColor(100, 100, 100);
  doc.text(dateRange, 105, 30, { align: 'center' });
  
  // Add BabyBloom branding
  doc.setFontSize(10);
  doc.setTextColor(150, 150, 150);
  doc.text('Generated by BabyBloom App', 105, 38, { align: 'center' });
  
  let yPosition = 50;
  
  // Child info
  doc.setFontSize(16);
  doc.setTextColor(64, 122, 214);
  doc.text('Child Information', 14, yPosition);
  yPosition += 10;
  
  doc.setFontSize(12);
  doc.setTextColor(80, 80, 80);
  doc.text(`Name: ${childData.name}`, 14, yPosition);
  yPosition += 8;
  
  if (childData.dateOfBirth) {
    doc.text(`Date of Birth: ${childData.dateOfBirth}`, 14, yPosition);
    yPosition += 8;
  }
  
  if (childData.age) {
    doc.text(`Current Age: ${childData.age}`, 14, yPosition);
    yPosition += 8;
  }
  
  yPosition += 10;
  
  // Milestones section
  if (options.includeMilestones && childData.milestones && childData.milestones.length > 0) {
    doc.setFontSize(16);
    doc.setTextColor(64, 122, 214);
    doc.text('Developmental Milestones', 14, yPosition);
    yPosition += 10;
    
    // @ts-ignore - jspdf-autotable extends jsPDF but TypeScript doesn't recognize it
    doc.autoTable({
      startY: yPosition,
      head: [['Date', 'Milestone']],
      body: childData.milestones.map(milestone => [
        format(milestone.date, 'MMM d, yyyy'),
        milestone.description
      ]),
      theme: 'grid',
      headStyles: { 
        fillColor: [230, 236, 245],
        textColor: [70, 70, 70],
        fontStyle: 'bold'
      },
      styles: {
        fontSize: 10,
        cellPadding: 5
      },
      columnStyles: {
        0: { cellWidth: 40 }
      }
    });
    
    // @ts-ignore - autoTable adds a lastAutoTable property
    yPosition = doc.lastAutoTable.finalY + 15;
  }
  
  // Growth measurements section
  if (options.includeGrowth && childData.measurements && childData.measurements.length > 0) {
    // Check if we need a new page
    if (yPosition > 230) {
      doc.addPage();
      yPosition = 20;
    }
    
    doc.setFontSize(16);
    doc.setTextColor(64, 122, 214);
    doc.text('Growth Measurements', 14, yPosition);
    yPosition += 10;
    
    // @ts-ignore
    doc.autoTable({
      startY: yPosition,
      head: [['Date', 'Weight (kg)', 'Height (cm)', 'Head (cm)']],
      body: childData.measurements.map(measurement => [
        format(measurement.date, 'MMM d, yyyy'),
        measurement.weight?.toFixed(2) || '-',
        measurement.height?.toFixed(1) || '-',
        measurement.headCircumference?.toFixed(1) || '-'
      ]),
      theme: 'grid',
      headStyles: { 
        fillColor: [230, 236, 245],
        textColor: [70, 70, 70],
        fontStyle: 'bold'
      },
      styles: {
        fontSize: 10,
        cellPadding: 5
      }
    });
    
    // @ts-ignore
    yPosition = doc.lastAutoTable.finalY + 15;
  }
  
  // Appointments section
  if (options.includeAppointments && childData.appointments && childData.appointments.length > 0) {
    // Check if we need a new page
    if (yPosition > 230) {
      doc.addPage();
      yPosition = 20;
    }
    
    doc.setFontSize(16);
    doc.setTextColor(64, 122, 214);
    doc.text('Medical Appointments', 14, yPosition);
    yPosition += 10;
    
    // @ts-ignore
    doc.autoTable({
      startY: yPosition,
      head: [['Date', 'Type', 'Notes']],
      body: childData.appointments.map(appointment => [
        format(appointment.date, 'MMM d, yyyy'),
        appointment.type,
        appointment.notes || ''
      ]),
      theme: 'grid',
      headStyles: { 
        fillColor: [230, 236, 245],
        textColor: [70, 70, 70],
        fontStyle: 'bold'
      },
      styles: {
        fontSize: 10,
        cellPadding: 5
      },
      columnStyles: {
        0: { cellWidth: 40 },
        1: { cellWidth: 50 }
      }
    });
    
    // @ts-ignore
    yPosition = doc.lastAutoTable.finalY + 15;
  }
  
  // Photos section
  if (options.includePhotos && childData.photos && childData.photos.length > 0) {
    // Photos would be added here, but requires more complex handling with external images
    // This would involve fetching each image, converting to Base64, and adding to the PDF
    // For simplicity, just adding a note about photos
    
    // Check if we need a new page
    if (yPosition > 250) {
      doc.addPage();
      yPosition = 20;
    }
    
    doc.setFontSize(16);
    doc.setTextColor(64, 122, 214);
    doc.text('Photo Gallery', 14, yPosition);
    yPosition += 10;
    
    doc.setFontSize(10);
    doc.setTextColor(80, 80, 80);
    doc.text(`${childData.photos.length} photos are available in the BabyBloom app`, 14, yPosition);
  }
  
  // Footer
  const pageCount = doc.getNumberOfPages();
  for (let i = 1; i <= pageCount; i++) {
    doc.setPage(i);
    doc.setFontSize(10);
    doc.setTextColor(150, 150, 150);
    doc.text(
      `Page ${i} of ${pageCount}`,
      doc.internal.pageSize.getWidth() / 2,
      doc.internal.pageSize.getHeight() - 10,
      { align: 'center' }
    );
    
    // Add generation date
    doc.text(
      `Generated on ${format(new Date(), 'MMM d, yyyy')}`,
      doc.internal.pageSize.getWidth() - 15,
      doc.internal.pageSize.getHeight() - 10,
      { align: 'right' }
    );
  }
  
  // Convert to blob for download or email
  return doc.output('blob');
};

/**
 * Email a PDF report to a specified email address
 * 
 * @param pdfBlob The PDF blob to send
 * @param email Recipient email address
 * @param childName Name of the child for the email subject
 * @returns Promise that resolves when the email is sent
 */
export const emailPDFReport = async (pdfBlob: Blob, email: string, childName: string): Promise<boolean> => {
  // In a real app, this would send the PDF to a server endpoint that would email it
  // For demo purposes, we'll just simulate the process
  
  console.log(`Sending PDF for ${childName} to ${email}...`);
  
  // Simulate API call delay
  await new Promise(resolve => setTimeout(resolve, 1500));
  
  // This would typically return a response from the API
  // For now, we'll just return success
  return true;
};

/**
 * Generate a PDF of scheduled reminders for appointments
 * 
 * @param childrenData Array of child data with appointments
 * @param email Recipient email address
 * @returns Promise that resolves when the email is sent
 */
export const generateAppointmentReminders = async (
  childrenData: ChildData[],
  email: string
): Promise<boolean> => {
  // Create a new PDF document
  const doc = new jsPDF();
  
  // Add title and header
  doc.setFontSize(24);
  doc.setTextColor(64, 122, 214);
  doc.text('Upcoming Appointments', 105, 20, { align: 'center' });
  
  doc.setFontSize(14);
  doc.setTextColor(100, 100, 100);
  const nextWeek = new Date();
  nextWeek.setDate(nextWeek.getDate() + 7);
  const dateRange = `${format(new Date(), 'MMM d, yyyy')} to ${format(nextWeek, 'MMM d, yyyy')}`;
  doc.text(dateRange, 105, 30, { align: 'center' });
  
  let yPosition = 50;
  
  // Aggregate all appointments from all children
  const allAppointments = childrenData.flatMap(child => 
    (child.appointments || []).map(appointment => ({
      childName: child.name,
      ...appointment
    }))
  );
  
  // Sort by date
  allAppointments.sort((a, b) => a.date.getTime() - b.date.getTime());
  
  // Filter to only show upcoming appointments within the next month
  const oneMonthFromNow = new Date();
  oneMonthFromNow.setMonth(oneMonthFromNow.getMonth() + 1);
  
  const upcomingAppointments = allAppointments.filter(
    appointment => appointment.date > new Date() && appointment.date < oneMonthFromNow
  );
  
  if (upcomingAppointments.length === 0) {
    doc.setFontSize(12);
    doc.setTextColor(80, 80, 80);
    doc.text('No upcoming appointments in the next month.', 105, yPosition, { align: 'center' });
  } else {
    // @ts-ignore
    doc.autoTable({
      startY: yPosition,
      head: [['Date', 'Child', 'Appointment Type', 'Notes']],
      body: upcomingAppointments.map(appointment => [
        format(appointment.date, 'MMM d, yyyy'),
        appointment.childName,
        appointment.type,
        appointment.notes || ''
      ]),
      theme: 'grid',
      headStyles: { 
        fillColor: [230, 236, 245],
        textColor: [70, 70, 70],
        fontStyle: 'bold'
      },
      styles: {
        fontSize: 10,
        cellPadding: 5
      }
    });
  }
  
  // Convert to blob and email
  const pdfBlob = doc.output('blob');
  
  // Simulate sending email
  console.log(`Sending appointment reminders to ${email}...`);
  await new Promise(resolve => setTimeout(resolve, 1500));
  
  return true;
};
